{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { useAuth } from '../contexts/AuthContext';\nimport api from '../services/api';\nexport const useNotifications = () => {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const {\n    user\n  } = useAuth();\n\n  // Mock notifications for development\n  const mockNotifications = [{\n    id: 1,\n    title: 'Appointment Reminder',\n    message: 'Your Abhyanga session is scheduled for tomorrow at 10:00 AM',\n    type: 'appointment',\n    isRead: false,\n    createdAt: '2025-01-14T18:00:00Z',\n    actionUrl: '/appointments/1'\n  }, {\n    id: 2,\n    title: 'Treatment Progress',\n    message: 'Congratulations! You have completed 65% of your Panchakarma treatment',\n    type: 'success',\n    isRead: false,\n    createdAt: '2025-01-14T12:00:00Z',\n    actionUrl: '/progress'\n  }, {\n    id: 3,\n    title: 'Dietary Guidelines',\n    message: 'New dietary recommendations have been added to your treatment plan',\n    type: 'info',\n    isRead: true,\n    createdAt: '2025-01-13T15:30:00Z',\n    actionUrl: '/diet-plan'\n  }, {\n    id: 4,\n    title: 'Preparation Reminder',\n    message: 'Please avoid heavy meals 2 hours before your Shirodhara session',\n    type: 'reminder',\n    isRead: false,\n    createdAt: '2025-01-13T09:00:00Z',\n    actionUrl: '/appointments/2'\n  }, {\n    id: 5,\n    title: 'Milestone Achievement',\n    message: 'You have reached the midpoint of your treatment journey!',\n    type: 'success',\n    isRead: true,\n    createdAt: '2025-01-12T16:45:00Z',\n    actionUrl: '/milestones'\n  }, {\n    id: 6,\n    title: 'Session Feedback',\n    message: 'Please provide feedback for your recent Abhyanga session',\n    type: 'info',\n    isRead: true,\n    createdAt: '2025-01-11T20:00:00Z',\n    actionUrl: '/feedback/1'\n  }];\n  const fetchNotifications = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // In production, this would be actual API calls\n      // const response = await api.get('/notifications');\n      // setNotifications(response.data);\n\n      // For now, use mock data\n      setTimeout(() => {\n        setNotifications(mockNotifications);\n        const unread = mockNotifications.filter(n => !n.isRead).length;\n        setUnreadCount(unread);\n        setLoading(false);\n      }, 500);\n    } catch (err) {\n      setError(err.message || 'Failed to fetch notifications');\n      setLoading(false);\n    }\n  };\n  const markAsRead = async notificationId => {\n    try {\n      // In production:\n      // await api.put(`/notifications/${notificationId}/read`);\n\n      // Mock implementation\n      setNotifications(prev => prev.map(notification => notification.id === notificationId ? {\n        ...notification,\n        isRead: true\n      } : notification));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    } catch (err) {\n      setError(err.message || 'Failed to mark notification as read');\n      throw err;\n    }\n  };\n  const markAllAsRead = async () => {\n    try {\n      // In production:\n      // await api.put('/notifications/mark-all-read');\n\n      // Mock implementation\n      setNotifications(prev => prev.map(notification => ({\n        ...notification,\n        isRead: true\n      })));\n      setUnreadCount(0);\n    } catch (err) {\n      setError(err.message || 'Failed to mark all notifications as read');\n      throw err;\n    }\n  };\n  const deleteNotification = async notificationId => {\n    try {\n      // In production:\n      // await api.delete(`/notifications/${notificationId}`);\n\n      // Mock implementation\n      const notification = notifications.find(n => n.id === notificationId);\n      setNotifications(prev => prev.filter(n => n.id !== notificationId));\n      if (notification && !notification.isRead) {\n        setUnreadCount(prev => Math.max(0, prev - 1));\n      }\n    } catch (err) {\n      setError(err.message || 'Failed to delete notification');\n      throw err;\n    }\n  };\n  const sendNotification = async notificationData => {\n    try {\n      // In production:\n      // const response = await api.post('/notifications', notificationData);\n      // const newNotification = response.data;\n\n      // Mock implementation\n      const newNotification = {\n        id: Date.now(),\n        ...notificationData,\n        isRead: false,\n        createdAt: new Date().toISOString()\n      };\n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n      return newNotification;\n    } catch (err) {\n      setError(err.message || 'Failed to send notification');\n      throw err;\n    }\n  };\n  const getNotificationsByType = type => {\n    return notifications.filter(notification => notification.type === type);\n  };\n  const getUnreadNotifications = () => {\n    return notifications.filter(notification => !notification.isRead);\n  };\n  const getRecentNotifications = (limit = 5) => {\n    return notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).slice(0, limit);\n  };\n\n  // WebSocket connection for real-time notifications (mock implementation)\n  useEffect(() => {\n    if (!user) return;\n\n    // In production, this would establish a WebSocket connection\n    // const ws = new WebSocket(`ws://localhost:3001/notifications?userId=${user.id}`);\n    // \n    // ws.onmessage = (event) => {\n    //   const notification = JSON.parse(event.data);\n    //   setNotifications(prev => [notification, ...prev]);\n    //   setUnreadCount(prev => prev + 1);\n    // };\n    // \n    // return () => ws.close();\n\n    // Mock real-time notification simulation\n    const interval = setInterval(() => {\n      // Randomly add a new notification (for demo purposes)\n      if (Math.random() < 0.1) {\n        // 10% chance every 30 seconds\n        const mockNewNotification = {\n          id: Date.now(),\n          title: 'New Update',\n          message: 'You have a new update in your treatment plan',\n          type: 'info',\n          isRead: false,\n          createdAt: new Date().toISOString(),\n          actionUrl: '/dashboard'\n        };\n        setNotifications(prev => [mockNewNotification, ...prev]);\n        setUnreadCount(prev => prev + 1);\n      }\n    }, 30000); // Check every 30 seconds\n\n    return () => clearInterval(interval);\n  }, [user]);\n  useEffect(() => {\n    if (user) {\n      fetchNotifications();\n    }\n  }, [user]);\n  return {\n    notifications,\n    unreadCount,\n    loading,\n    error,\n    markAsRead,\n    markAllAsRead,\n    deleteNotification,\n    sendNotification,\n    getNotificationsByType,\n    getUnreadNotifications,\n    getRecentNotifications,\n    refetch: fetchNotifications\n  };\n};\n_s(useNotifications, \"gsjFTMLtHPQzh8U/7xXp3PqfrEo=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useState","useEffect","useAuth","api","useNotifications","_s","notifications","setNotifications","unreadCount","setUnreadCount","loading","setLoading","error","setError","user","mockNotifications","id","title","message","type","isRead","createdAt","actionUrl","fetchNotifications","setTimeout","unread","filter","n","length","err","markAsRead","notificationId","prev","map","notification","Math","max","markAllAsRead","deleteNotification","find","sendNotification","notificationData","newNotification","Date","now","toISOString","getNotificationsByType","getUnreadNotifications","getRecentNotifications","limit","sort","a","b","slice","interval","setInterval","random","mockNewNotification","clearInterval","refetch"],"sources":["C:/Users/Utkarsh/OneDrive/Desktop/AYURSUTRA DRAFT/ayursutra/frontend/src/hooks/useNotifications.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { useAuth } from '../contexts/AuthContext';\nimport api from '../services/api';\n\nexport const useNotifications = () => {\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const { user } = useAuth();\n\n  // Mock notifications for development\n  const mockNotifications = [\n    {\n      id: 1,\n      title: 'Appointment Reminder',\n      message: 'Your Abhyanga session is scheduled for tomorrow at 10:00 AM',\n      type: 'appointment',\n      isRead: false,\n      createdAt: '2025-01-14T18:00:00Z',\n      actionUrl: '/appointments/1'\n    },\n    {\n      id: 2,\n      title: 'Treatment Progress',\n      message: 'Congratulations! You have completed 65% of your Panchakarma treatment',\n      type: 'success',\n      isRead: false,\n      createdAt: '2025-01-14T12:00:00Z',\n      actionUrl: '/progress'\n    },\n    {\n      id: 3,\n      title: 'Dietary Guidelines',\n      message: 'New dietary recommendations have been added to your treatment plan',\n      type: 'info',\n      isRead: true,\n      createdAt: '2025-01-13T15:30:00Z',\n      actionUrl: '/diet-plan'\n    },\n    {\n      id: 4,\n      title: 'Preparation Reminder',\n      message: 'Please avoid heavy meals 2 hours before your Shirodhara session',\n      type: 'reminder',\n      isRead: false,\n      createdAt: '2025-01-13T09:00:00Z',\n      actionUrl: '/appointments/2'\n    },\n    {\n      id: 5,\n      title: 'Milestone Achievement',\n      message: 'You have reached the midpoint of your treatment journey!',\n      type: 'success',\n      isRead: true,\n      createdAt: '2025-01-12T16:45:00Z',\n      actionUrl: '/milestones'\n    },\n    {\n      id: 6,\n      title: 'Session Feedback',\n      message: 'Please provide feedback for your recent Abhyanga session',\n      type: 'info',\n      isRead: true,\n      createdAt: '2025-01-11T20:00:00Z',\n      actionUrl: '/feedback/1'\n    }\n  ];\n\n  const fetchNotifications = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      // In production, this would be actual API calls\n      // const response = await api.get('/notifications');\n      // setNotifications(response.data);\n      \n      // For now, use mock data\n      setTimeout(() => {\n        setNotifications(mockNotifications);\n        const unread = mockNotifications.filter(n => !n.isRead).length;\n        setUnreadCount(unread);\n        setLoading(false);\n      }, 500);\n      \n    } catch (err) {\n      setError(err.message || 'Failed to fetch notifications');\n      setLoading(false);\n    }\n  };\n\n  const markAsRead = async (notificationId) => {\n    try {\n      // In production:\n      // await api.put(`/notifications/${notificationId}/read`);\n      \n      // Mock implementation\n      setNotifications(prev => \n        prev.map(notification => \n          notification.id === notificationId \n            ? { ...notification, isRead: true }\n            : notification\n        )\n      );\n      \n      setUnreadCount(prev => Math.max(0, prev - 1));\n      \n    } catch (err) {\n      setError(err.message || 'Failed to mark notification as read');\n      throw err;\n    }\n  };\n\n  const markAllAsRead = async () => {\n    try {\n      // In production:\n      // await api.put('/notifications/mark-all-read');\n      \n      // Mock implementation\n      setNotifications(prev => \n        prev.map(notification => ({ ...notification, isRead: true }))\n      );\n      \n      setUnreadCount(0);\n      \n    } catch (err) {\n      setError(err.message || 'Failed to mark all notifications as read');\n      throw err;\n    }\n  };\n\n  const deleteNotification = async (notificationId) => {\n    try {\n      // In production:\n      // await api.delete(`/notifications/${notificationId}`);\n      \n      // Mock implementation\n      const notification = notifications.find(n => n.id === notificationId);\n      setNotifications(prev => prev.filter(n => n.id !== notificationId));\n      \n      if (notification && !notification.isRead) {\n        setUnreadCount(prev => Math.max(0, prev - 1));\n      }\n      \n    } catch (err) {\n      setError(err.message || 'Failed to delete notification');\n      throw err;\n    }\n  };\n\n  const sendNotification = async (notificationData) => {\n    try {\n      // In production:\n      // const response = await api.post('/notifications', notificationData);\n      // const newNotification = response.data;\n      \n      // Mock implementation\n      const newNotification = {\n        id: Date.now(),\n        ...notificationData,\n        isRead: false,\n        createdAt: new Date().toISOString()\n      };\n      \n      setNotifications(prev => [newNotification, ...prev]);\n      setUnreadCount(prev => prev + 1);\n      \n      return newNotification;\n    } catch (err) {\n      setError(err.message || 'Failed to send notification');\n      throw err;\n    }\n  };\n\n  const getNotificationsByType = (type) => {\n    return notifications.filter(notification => notification.type === type);\n  };\n\n  const getUnreadNotifications = () => {\n    return notifications.filter(notification => !notification.isRead);\n  };\n\n  const getRecentNotifications = (limit = 5) => {\n    return notifications\n      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n      .slice(0, limit);\n  };\n\n  // WebSocket connection for real-time notifications (mock implementation)\n  useEffect(() => {\n    if (!user) return;\n\n    // In production, this would establish a WebSocket connection\n    // const ws = new WebSocket(`ws://localhost:3001/notifications?userId=${user.id}`);\n    // \n    // ws.onmessage = (event) => {\n    //   const notification = JSON.parse(event.data);\n    //   setNotifications(prev => [notification, ...prev]);\n    //   setUnreadCount(prev => prev + 1);\n    // };\n    // \n    // return () => ws.close();\n\n    // Mock real-time notification simulation\n    const interval = setInterval(() => {\n      // Randomly add a new notification (for demo purposes)\n      if (Math.random() < 0.1) { // 10% chance every 30 seconds\n        const mockNewNotification = {\n          id: Date.now(),\n          title: 'New Update',\n          message: 'You have a new update in your treatment plan',\n          type: 'info',\n          isRead: false,\n          createdAt: new Date().toISOString(),\n          actionUrl: '/dashboard'\n        };\n        \n        setNotifications(prev => [mockNewNotification, ...prev]);\n        setUnreadCount(prev => prev + 1);\n      }\n    }, 30000); // Check every 30 seconds\n\n    return () => clearInterval(interval);\n  }, [user]);\n\n  useEffect(() => {\n    if (user) {\n      fetchNotifications();\n    }\n  }, [user]);\n\n  return {\n    notifications,\n    unreadCount,\n    loading,\n    error,\n    markAsRead,\n    markAllAsRead,\n    deleteNotification,\n    sendNotification,\n    getNotificationsByType,\n    getUnreadNotifications,\n    getRecentNotifications,\n    refetch: fetchNotifications\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}